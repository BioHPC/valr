<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Jay Hesselberth jay.hesselberth@gmail.com" />

<meta name="date" content="2016-09-16" />

<title>valr: Genome interval arithmetic in R</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore"><code>valr</code>: Genome interval arithmetic in R</h1>
<h4 class="author"><em>Jay Hesselberth <a href="mailto:jay.hesselberth@gmail.com">jay.hesselberth@gmail.com</a></em></h4>
<h4 class="date"><em>2016-09-16</em></h4>



<div id="overview" class="section level1">
<h1>Overview</h1>
<p><code>valr</code> provides tools to read and manipulate genome intervals and signals, similar to the standalone <a href="http://bedtools.readthedocs.org/en/latest/"><code>BEDtools</code></a> suite. <code>valr</code> enables BEDtools-like analysis in the R/RStudio environment, and uses modern R tools for a terse, expressive syntax. Compute-intensive algorithms are implemented in <a href="http://www.rcpp.org/"><code>Rcpp</code></a>/C++, and many methods take advantage of the speed and grouping capability provided by <a href="https://github.com/hadley/dplyr"><code>dplyr</code></a>.</p>
<p>We provide several introductions to <code>valr</code>:</p>
<ul>
<li>This comprehensive <code>vignette</code> covering the core methods.</li>
<li>A tutorial that demonstrates how to use <code>valr</code> in “real-world” applications.</li>
<li>A <code>shiny</code> application that demonstrates interactive analysis of genome-scale data sets.</li>
</ul>
<div id="installation" class="section level2">
<h2>Installation</h2>
<p><code>valr</code> can be installed from github, and will be eventually deposited in CRAN.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">devtools::<span class="kw">install_github</span>(<span class="st">'jayhesselberth/valr'</span>)</code></pre></div>
</div>
<div id="comparison-to-other-tools" class="section level2">
<h2>Comparison to other tools</h2>
<p><strong>Why another tool set for interval manipulations?</strong> We already have <a href="http://bedtools.readthedocs.org/en/latest/">BEDtools</a>, <a href="http://bedops.readthedocs.org/en/latest/index.html">bedops</a>, <a href="https://pythonhosted.org/pybedtools/">pybedtools</a>, <a href="https://bioconductor.org/packages/release/bioc/html/GenomicRanges.html">GenomicRanges</a>, <a href="https://cran.r-project.org/web/packages/bedr/index.html">bedr</a> and <a href="https://bioconductor.org/packages/release/bioc/html/IRanges.html">IRanges</a>.</p>
<p>We were motivated to develop a toolset that:</p>
<ul>
<li>Combines analysis and visualization in RStudio.</li>
<li>Can be used to generate reports with Rmarkdown.</li>
<li>Is highly extensible. New tools are quickly implemented on the R side.</li>
<li>Leverages the “modern R” syntax, using <code>dplyr</code> and the pipe operator from <code>magrittr</code> (<code>%&gt;%</code>).</li>
<li>Maximizes speed by implementing compute-intensive algorithms in <code>Rcpp</code>.</li>
<li>Facilitates interactive visulaizations with <a href="http://shiny.rstudio.com/"><code>shiny</code></a>.</li>
</ul>
<p>We anticipate <code>valr</code> will mainly be used for analysis of pre-processed data in BED, bedGraph and VCF formats. Most users will have processed their aligned reads from BAM format to bedGraph, so we do not foresee supporting BAM directly. We would entertain requests for GTF / GFF support if there is interest, as <code>tidyr</code> makes it easy to convert these to BED12.</p>
<p>Certain algorithms in <code>valr</code> were implemented in <code>Rcpp</code> (including <a href="https://github.com/jayhesselberth/valr/tree/master/src">intersect, merge, subtract, closest</a>) to enable fluid interactive analysis. See the <a href="#benchmarks">benchmarks</a> section for details.</p>
</div>
<div id="non-standard-evaluation" class="section level2">
<h2>Non-standard evaluation</h2>
<p>Several of the methods in <code>valr</code> use <a href="https://cran.r-project.org/web/packages/dplyr/vignettes/nse.html">NSE</a> for an expressive syntax. Columns are referred to by name and can be used in multiple name/value expressions for summaries.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bed_map</span>(x, y, <span class="dt">mean =</span> <span class="kw">mean</span>(value), <span class="dt">var =</span> <span class="kw">var</span>(value))
<span class="kw">bed_merge</span>(x, <span class="dt">concat =</span> <span class="kw">concat</span>(value), <span class="dt">max =</span> <span class="kw">max</span>(value))</code></pre></div>
</div>
<div id="getting-started" class="section level2">
<h2>Getting started</h2>
<p>Here is an example using <code>valr</code> that creates</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(valr)</code></pre></div>
</div>
</div>
<div id="reading-data" class="section level1 tabset">
<h1>Reading data</h1>
<p><code>valr</code> has several methods to read interval data. These methods:</p>
<ul>
<li>Take local files or URLs as input.</li>
<li>Return a <code>data.frame</code> in <code>tibble::tbl_df</code> format.</li>
<li>Assign consistent <code>chrom</code>, <code>start</code> and <code>end</code> column names.</li>
<li>Use <a href="https://github.com/hadley/readr"><code>readr</code></a> for speed.</li>
<li>Coerce column types.</li>
</ul>
<p>The methods include:</p>
<ul>
<li><code>read_bed()</code>: read a BED3+ file</li>
<li><code>read_bed12()</code>: read a BED12 file</li>
<li><code>read_bedgraph()</code>: read a bedGraph file</li>
<li><code>read_genome()</code>: read a UCSC “chrom size” file</li>
<li><code>read_vcf()</code>: read the Variant Call Format</li>
<li><code>read_narrowpeak()</code>: read narrowPeak files</li>
<li><code>read_broadpeak()</code>: read broadPeak files</li>
</ul>
<div id="bed-files" class="section level2">
<h2>BED files</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_bed</span>(<span class="kw">system.file</span>(<span class="st">'extdata'</span>, <span class="st">'3fields.bed.gz'</span>, <span class="dt">package =</span> <span class="st">'valr'</span>))
<span class="co">#&gt; # A tibble: 10 × 3</span>
<span class="co">#&gt;    chrom  start    end</span>
<span class="co">#&gt;    &lt;chr&gt;  &lt;int&gt;  &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1  11873  14409</span>
<span class="co">#&gt; 2   chr1  14361  19759</span>
<span class="co">#&gt; 3   chr1  14406  29370</span>
<span class="co">#&gt; 4   chr1  34610  36081</span>
<span class="co">#&gt; 5   chr1  69090  70008</span>
<span class="co">#&gt; 6   chr1 134772 140566</span>
<span class="co">#&gt; 7   chr1 321083 321115</span>
<span class="co">#&gt; 8   chr1 321145 321207</span>
<span class="co">#&gt; 9   chr1 322036 326938</span>
<span class="co">#&gt; 10  chr1 327545 328439</span>
<span class="kw">read_bed</span>(<span class="dt">n_fields =</span> <span class="dv">6</span>, <span class="kw">system.file</span>(<span class="st">'extdata'</span>, <span class="st">'6fields.bed.gz'</span>, <span class="dt">package =</span> <span class="st">'valr'</span>))
<span class="co">#&gt; # A tibble: 10 × 6</span>
<span class="co">#&gt;    chrom  start    end         name score strand</span>
<span class="co">#&gt;    &lt;chr&gt;  &lt;int&gt;  &lt;int&gt;        &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;</span>
<span class="co">#&gt; 1   chr1  11873  14409      DDX11L1     3      +</span>
<span class="co">#&gt; 2   chr1  14361  19759       WASH7P    10      -</span>
<span class="co">#&gt; 3   chr1  14406  29370       WASH7P     7      -</span>
<span class="co">#&gt; 4   chr1  34610  36081      FAM138F     3      -</span>
<span class="co">#&gt; 5   chr1  69090  70008        OR4F5     1      +</span>
<span class="co">#&gt; 6   chr1 134772 140566    LOC729737     3      -</span>
<span class="co">#&gt; 7   chr1 321083 321115     DQ597235     1      +</span>
<span class="co">#&gt; 8   chr1 321145 321207     DQ599768     1      +</span>
<span class="co">#&gt; 9   chr1 322036 326938 LOC100133331     3      +</span>
<span class="co">#&gt; 10  chr1 327545 328439    LOC388312     1      +</span>
<span class="kw">read_bed12</span>(<span class="kw">system.file</span>(<span class="st">'extdata'</span>, <span class="st">'12fields.bed.gz'</span>, <span class="dt">package =</span> <span class="st">'valr'</span>))
<span class="co">#&gt; # A tibble: 3 × 12</span>
<span class="co">#&gt;   chrom   start     end      name score strand cds_start cds_end item_rgb</span>
<span class="co">#&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;int&gt;     &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;int&gt;   &lt;int&gt;    &lt;chr&gt;</span>
<span class="co">#&gt; 1  chr1 4797973 4836816  testgene     1      +   4797973 4836816        .</span>
<span class="co">#&gt; 2 chr10 4848118 4880877 diffchrom     1      +   4848118 4880877        .</span>
<span class="co">#&gt; 3 chr20 5073253 5152630 negstrand     1      -   5073253 5152630        .</span>
<span class="co">#&gt; # ... with 3 more variables: exon_count &lt;int&gt;, exon_sizes &lt;chr&gt;,</span>
<span class="co">#&gt; #   exon_starts &lt;chr&gt;</span></code></pre></div>
</div>
<div id="genome-files" class="section level2">
<h2>Genome files</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">genome &lt;-<span class="st"> </span><span class="kw">read_genome</span>(<span class="kw">system.file</span>(<span class="st">'extdata'</span>, <span class="st">'hg19.chrom.sizes.gz'</span>, <span class="dt">package =</span> <span class="st">'valr'</span>))</code></pre></div>
</div>
<div id="bedgraph-files" class="section level2">
<h2>bedGraph files</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_bedgraph</span>(<span class="kw">system.file</span>(<span class="st">'extdata'</span>, <span class="st">'test.bg.gz'</span>, <span class="dt">package =</span> <span class="st">'valr'</span>))
<span class="co">#&gt; # A tibble: 4 × 4</span>
<span class="co">#&gt;   chrom    start      end value</span>
<span class="co">#&gt;   &lt;chr&gt;    &lt;int&gt;    &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 chr19 49302000 49302300 -1.00</span>
<span class="co">#&gt; 2 chr19 49302300 49302600 -0.75</span>
<span class="co">#&gt; 3 chr19 49302600 49302900 -0.50</span>
<span class="co">#&gt; 4 chr19 49302900 49303200 -0.25</span></code></pre></div>
</div>
<div id="vcf-files" class="section level2">
<h2>VCF files</h2>
<p><code>read_vcf()</code> reads VCF files and assigns <code>chrom</code>, <code>start</code> and <code>end</code> columns to be used to downstream interval comparisons. Note the interval size is calculated as the length of the <code>REF</code> field in the original file.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_vcf</span>(<span class="kw">system.file</span>(<span class="st">'extdata'</span>, <span class="st">'test.vcf.gz'</span>, <span class="dt">package =</span> <span class="st">'valr'</span>))
<span class="co">#&gt; # A tibble: 115 × 201</span>
<span class="co">#&gt;    CHROM   POS    ID                                          REF</span>
<span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;                                        &lt;chr&gt;</span>
<span class="co">#&gt; 1      1 10172     .                                       CCCTAA</span>
<span class="co">#&gt; 2      1 10390     . CCCCTAACCCCTAACCCTAACCCTAACCCTAACCCTAACCCTAA</span>
<span class="co">#&gt; 3      1 10397     .                                CCCCTAACCCTAA</span>
<span class="co">#&gt; 4      1 10403     .       ACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAAC</span>
<span class="co">#&gt; 5      1 10409     .             ACCCTAACCCTAACCCTAACCCTAACCCTAAC</span>
<span class="co">#&gt; 6      1 10415     .                   ACCCTAACCCTAACCCTAACCCTAAC</span>
<span class="co">#&gt; 7      1 10421     .                         ACCCTAACCCTAACCCTAAC</span>
<span class="co">#&gt; 8      1 10428     .                                       CCCTAA</span>
<span class="co">#&gt; 9      1 10440     .                                            C</span>
<span class="co">#&gt; 10     1 10478     .                                            C</span>
<span class="co">#&gt; # ... with 105 more rows, and 197 more variables: ALT &lt;chr&gt;, QUAL &lt;dbl&gt;,</span>
<span class="co">#&gt; #   FILTER &lt;chr&gt;, INFO &lt;chr&gt;, FORMAT &lt;chr&gt;, `101976-101976` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100920-100920` &lt;chr&gt;, `100231-100231` &lt;chr&gt;, `100232-100232` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100919-100919` &lt;chr&gt;, `101977-101977` &lt;chr&gt;, `100630-100630` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100640-100640` &lt;chr&gt;, `100631-100631` &lt;chr&gt;, `101583-101583` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101584-101584` &lt;chr&gt;, `101732-101732` &lt;chr&gt;, `101016-101016` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101708-101708` &lt;chr&gt;, `101730-101730` &lt;chr&gt;, `101582-101582` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101731-101731` &lt;chr&gt;, `101809-101809` &lt;chr&gt;, `101653-101653` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101652-101652` &lt;chr&gt;, `101806-101806` &lt;chr&gt;, `101807-101807` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101808-101808` &lt;chr&gt;, `101810-101810` &lt;chr&gt;, `101811-101811` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101812-101812` &lt;chr&gt;, `101813-101813` &lt;chr&gt;, `101814-101814` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101957-101957` &lt;chr&gt;, `101958-101958` &lt;chr&gt;, `100986-100986` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100987-100987` &lt;chr&gt;, `101897-101897` &lt;chr&gt;, `102071-102071` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102106-102106` &lt;chr&gt;, `101040-101040` &lt;chr&gt;, `101167-101167` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101041-101041` &lt;chr&gt;, `101042-101042` &lt;chr&gt;, `101168-101168` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101898-101898` &lt;chr&gt;, `102070-102070` &lt;chr&gt;, `102111-102111` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100988-100988` &lt;chr&gt;, `101896-101896` &lt;chr&gt;, `102110-102110` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102620-102620` &lt;chr&gt;, `102621-102621` &lt;chr&gt;, `102947-102947` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102948-102948` &lt;chr&gt;, `103089-103089` &lt;chr&gt;, `102693-102693` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102694-102694` &lt;chr&gt;, `102949-102949` &lt;chr&gt;, `102622-102622` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102623-102623` &lt;chr&gt;, `102624-102624` &lt;chr&gt;, `102722-102722` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `102712-102712` &lt;chr&gt;, `103339-103339` &lt;chr&gt;, `103124-103124` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `103161-103161` &lt;chr&gt;, `103125-103125` &lt;chr&gt;, `103171-103171` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `103338-103338` &lt;chr&gt;, `103372-103372` &lt;chr&gt;, `103193-103193` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100195-100195` &lt;chr&gt;, `100194-100194` &lt;chr&gt;, `101667-101667` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101137-101137` &lt;chr&gt;, `101291-101291` &lt;chr&gt;, `101292-101292` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101666-101666` &lt;chr&gt;, `32222-32222` &lt;chr&gt;, `32049-32049` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `32050-32050` &lt;chr&gt;, `32411-32411` &lt;chr&gt;, `32221-32221` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100147-100147` &lt;chr&gt;, `100149-100149` &lt;chr&gt;, `100243-100243` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100290-100290` &lt;chr&gt;, `100753-100753` &lt;chr&gt;, `100754-100754` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101377-101377` &lt;chr&gt;, `101426-101426` &lt;chr&gt;, `101435-101435` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101523-101523` &lt;chr&gt;, `101877-101877` &lt;chr&gt;, `100043-100043` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `100044-100044` &lt;chr&gt;, `100148-100148` &lt;chr&gt;, `100292-100292` &lt;chr&gt;,</span>
<span class="co">#&gt; #   `101381-101381` &lt;chr&gt;, ...</span></code></pre></div>
</div>
</div>
<div id="interval-manipulations" class="section level1">
<h1>Interval manipulations</h1>
<p><code>valr</code> implements several methods for manipulating sets of intervals. Some methods operate on a single set of intervals, while others compare two sets of intervals.</p>
<p>Many methods the same name as the corresponding <code>BEDtool</code>, and some commonly used <code>BEDtools</code> are implemented as <code>dplyr</code> pipes (e.g., see the <a href="#groupby"><code>group_by</code></a> section).</p>
<p>All methods accept one or more sets of <code>x</code> and <code>y</code> intervals, which must either be created using the <a href="#reading%20data"><code>read</code> methods</a>, or have <code>chrom</code>, <code>start</code> and <code>end</code> columns.</p>
<div id="single-set-operations" class="section level2 tabset">
<h2>Single set operations</h2>
<p>These methods operate on a single set of intervals:</p>
<ul>
<li><code>bed_sort()</code>: order intervals</li>
<li><code>bed_cluster()</code>: Cluster (but don’t merge) overlapping/nearby intervals.</li>
<li><code>bed_complement()</code>: extract intervals <em>not</em> represented by an interval file.</li>
<li><code>bed_merge()</code>: combine overlapping and nearby intervals into a single interval.</li>
<li><code>bed_flank()</code>: Generate new flanking intervals</li>
<li><code>bed_slop()</code>: Expand the size of input intervals</li>
<li><code>bed_shift()</code>: Shift the coordinates of an input set, bounded by a genome</li>
</ul>
<div id="sort" class="section level3">
<h3>Sort</h3>
<p><code>bed_sort</code> orders intervals based on a specification. <code>is_sorted</code> asks whether a tbl is already sorted.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
<span class="kw">is_sorted</span>(x)
<span class="co">#&gt; [1] FALSE</span>

y &lt;-<span class="st"> </span><span class="kw">bed_sort</span>(x)
y
<span class="co">#&gt; # A tibble: 1,000,000 × 3</span>
<span class="co">#&gt;    chrom start   end</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1    67  1067</span>
<span class="co">#&gt; 2   chr1  2556  3556</span>
<span class="co">#&gt; 3   chr1  5112  6112</span>
<span class="co">#&gt; 4   chr1  5962  6962</span>
<span class="co">#&gt; 5   chr1 11953 12953</span>
<span class="co">#&gt; 6   chr1 15314 16314</span>
<span class="co">#&gt; 7   chr1 18208 19208</span>
<span class="co">#&gt; 8   chr1 19963 20963</span>
<span class="co">#&gt; 9   chr1 25191 26191</span>
<span class="co">#&gt; 10  chr1 27998 28998</span>
<span class="co">#&gt; # ... with 999,990 more rows</span>

<span class="kw">is_sorted</span>(y)
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
</div>
<div id="cluster" class="section level3">
<h3>Cluster</h3>
<p><code>bed_cluster</code> identifies clustered intervals based on a distance specification and assigns them a unique <code>.id</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_cluster</span>(x, <span class="dt">max_dist =</span> <span class="dv">1000</span>)
y
<span class="co">#&gt; # A tibble: 1,000,000 × 4</span>
<span class="co">#&gt;    chrom     start       end   .id</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1  chr15  28562795  28563795  9191</span>
<span class="co">#&gt; 2  chr17  72786610  72787610 23616</span>
<span class="co">#&gt; 3   chr4 177829924 177830924 57480</span>
<span class="co">#&gt; 4   chr3  92465833  92466833 29829</span>
<span class="co">#&gt; 5   chr2 197298572 197299572 63933</span>
<span class="co">#&gt; 6  chr11  47638954  47639954 15139</span>
<span class="co">#&gt; 7   chr4 102871094 102872094 33159</span>
<span class="co">#&gt; 8   chr5  99446335  99447335 32395</span>
<span class="co">#&gt; 9  chr15  62850369  62851369 20207</span>
<span class="co">#&gt; 10  chr1  22035869  22036869  7039</span>
<span class="co">#&gt; # ... with 999,990 more rows</span></code></pre></div>
</div>
<div id="complement" class="section level3">
<h3>Complement</h3>
<p><code>bed_complement</code> identifies intervals in a genome that are not covered by an input.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_complement</span>(x, genome)
<span class="co">#&gt; # A tibble: 723,439 × 3</span>
<span class="co">#&gt;     chrom start   end</span>
<span class="co">#&gt;    &lt;fctr&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1    chr1     1  1995</span>
<span class="co">#&gt; 2    chr1  3574  5752</span>
<span class="co">#&gt; 3    chr1  6752  7414</span>
<span class="co">#&gt; 4    chr1  9964 16437</span>
<span class="co">#&gt; 5    chr1 17637 20780</span>
<span class="co">#&gt; 6    chr1 21780 24767</span>
<span class="co">#&gt; 7    chr1 25767 32421</span>
<span class="co">#&gt; 8    chr1 33421 36333</span>
<span class="co">#&gt; 9    chr1 37333 39165</span>
<span class="co">#&gt; 10   chr1 40165 40950</span>
<span class="co">#&gt; # ... with 723,429 more rows</span></code></pre></div>
</div>
<div id="merge" class="section level3">
<h3>Merge</h3>
<p><code>bed_merge</code> identifies overlapping intervals and reports new merged ones. <code>is_merged</code> asks whether a tbl is already merged. Values from merged intervals can be reported using name / value pairs.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="fl">1e6</span>
x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> n)
<span class="kw">is_merged</span>(x)
<span class="co">#&gt; [1] FALSE</span>

<span class="co"># add some signal</span>
x &lt;-<span class="st"> </span>x %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">signal =</span> <span class="kw">runif</span>(n))

<span class="kw">bed_merge</span>(x, <span class="dt">maxs =</span> <span class="kw">max</span>(signal))
<span class="co">#&gt; # A tibble: 723,506 × 4</span>
<span class="co">#&gt;    chrom start   end      maxs</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1   chr1  2947  3947 0.5971846</span>
<span class="co">#&gt; 2   chr1  7065  8065 0.4428205</span>
<span class="co">#&gt; 3   chr1  8330  9330 0.3206884</span>
<span class="co">#&gt; 4   chr1  9604 10604 0.1450251</span>
<span class="co">#&gt; 5   chr1 11456 12456 0.6171433</span>
<span class="co">#&gt; 6   chr1 13167 14229 0.8374596</span>
<span class="co">#&gt; 7   chr1 14543 16266 0.9136021</span>
<span class="co">#&gt; 8   chr1 20375 21375 0.9319875</span>
<span class="co">#&gt; 9   chr1 22472 23472 0.5033169</span>
<span class="co">#&gt; 10  chr1 23571 24932 0.6854593</span>
<span class="co">#&gt; # ... with 723,496 more rows</span></code></pre></div>
</div>
<div id="flank" class="section level3">
<h3>Flank</h3>
<p><code>bed_flank</code> creates new intervals that flank – but do not contain – the input intervals.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bed_flank</span>(x, genome, <span class="dt">both  =</span> <span class="dv">100</span>)
<span class="co">#&gt; # A tibble: 1,999,999 × 4</span>
<span class="co">#&gt;    chrom start   end    signal</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1   chr1  2847  2947 0.5971846</span>
<span class="co">#&gt; 2   chr1  3947  4047 0.5971846</span>
<span class="co">#&gt; 3   chr1  6965  7065 0.4428205</span>
<span class="co">#&gt; 4   chr1  8065  8165 0.4428205</span>
<span class="co">#&gt; 5   chr1  8230  8330 0.3206884</span>
<span class="co">#&gt; 6   chr1  9330  9430 0.3206884</span>
<span class="co">#&gt; 7   chr1  9504  9604 0.1450251</span>
<span class="co">#&gt; 8   chr1 10604 10704 0.1450251</span>
<span class="co">#&gt; 9   chr1 11356 11456 0.6171433</span>
<span class="co">#&gt; 10  chr1 12456 12556 0.6171433</span>
<span class="co">#&gt; # ... with 1,999,989 more rows</span></code></pre></div>
</div>
<div id="slop" class="section level3">
<h3>Slop</h3>
<p><code>bed_slop</code> pads input intervals based on a specification</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bed_slop</span>(x, genome, <span class="dt">both =</span> <span class="dv">100</span>)</code></pre></div>
</div>
<div id="shift" class="section level3">
<h3>Shift</h3>
<p><code>bed_shift</code> adjusts coordinates toward <code>start</code> or <code>end</code> by a defined <code>size</code>. Intervals created out of bounds are removed, or trimmed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bed_shift</span>(x, genome, <span class="dt">size =</span> <span class="dv">100</span>)
<span class="co">#&gt; # A tibble: 999,999 × 4</span>
<span class="co">#&gt;    chrom     start       end     signal</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;</span>
<span class="co">#&gt; 1   chr5  16594969  16595969 0.46639350</span>
<span class="co">#&gt; 2   chr8  29550699  29551699 0.49777739</span>
<span class="co">#&gt; 3   chr1 186085365 186086365 0.28976724</span>
<span class="co">#&gt; 4   chr1 218149500 218150500 0.73288199</span>
<span class="co">#&gt; 5   chr5  14521155  14522155 0.77252151</span>
<span class="co">#&gt; 6   chr9 105125989 105126989 0.87460066</span>
<span class="co">#&gt; 7   chr4  90861973  90862973 0.17494063</span>
<span class="co">#&gt; 8   chrX  60929860  60930860 0.03424133</span>
<span class="co">#&gt; 9  chr18   3232799   3233799 0.32038573</span>
<span class="co">#&gt; 10  chr2 189515404 189516404 0.40232824</span>
<span class="co">#&gt; # ... with 999,989 more rows</span></code></pre></div>
</div>
<div id="interval-spacing" class="section level3">
<h3>Interval spacing</h3>
<p>Interval spacing is easily computed using <code>dplyr</code>. Overlapping intervals must first be merged. Spacing for the first interval of each chromosome is undefined.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
x &lt;-<span class="st"> </span><span class="kw">bed_merge</span>(x)

x %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(chrom) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">.spacing =</span> start -<span class="st"> </span><span class="kw">lag</span>(end))
<span class="co">#&gt; Source: local data frame [723,578 x 4]</span>
<span class="co">#&gt; Groups: chrom [25]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;    chrom start   end .spacing</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1  3450  4450       NA</span>
<span class="co">#&gt; 2   chr1  8126  9126     3676</span>
<span class="co">#&gt; 3   chr1 10287 11604     1161</span>
<span class="co">#&gt; 4   chr1 14955 15955     3351</span>
<span class="co">#&gt; 5   chr1 18765 19765     2810</span>
<span class="co">#&gt; 6   chr1 20453 21453      688</span>
<span class="co">#&gt; 7   chr1 26866 27866     5413</span>
<span class="co">#&gt; 8   chr1 28173 29173      307</span>
<span class="co">#&gt; 9   chr1 30827 31827     1654</span>
<span class="co">#&gt; 10  chr1 36188 37188     4361</span>
<span class="co">#&gt; # ... with 723,568 more rows</span></code></pre></div>
</div>
</div>
<div id="multiple-set-operations" class="section level2 tabset">
<h2>Multiple set operations</h2>
<p>These methods compare two sets of intervals:</p>
<ul>
<li><code>bed_intersect()</code>: find overlapping intervals</li>
<li><code>bed_map()</code>: apply a function to selected columns for overlapping intervals</li>
<li><code>bed_subtract()</code>: Remove intervals based on overlaps between two files</li>
<li><code>bed_window()</code>: Find overlapping intervals within a window</li>
<li><code>bed_closest()</code>: find the closest intervals independent of overlaps</li>
</ul>
<div id="intersection" class="section level3">
<h3>Intersection</h3>
<p><code>bed_intersect</code> is implemented using an <a href="https://github.com/ekg/intervaltree/">interval tree</a> in <code>Rcpp</code>. Column names in the result have <code>.x</code> and <code>.y</code> suffixes, and an <code>.overlap</code> column contains the size of the intersection (values of <code>0</code> indicate book-ended, or touching intervals). See the <a href="#benchmarks">benchmarks</a> section for timing. Though <code>bed_intersect</code> is pretty fast already, we intend to further improve upon this by parallization with <a href="https://rcppcore.github.io/RcppParallel/"><code>RcppParallel</code></a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># intersect two sets of 1e6 intervals from hg19</span>
x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_intersect</span>(x, y)
<span class="co">#&gt; # A tibble: 647,112 × 6</span>
<span class="co">#&gt;    chrom start.x end.x start.y end.y .overlap</span>
<span class="co">#&gt;    &lt;chr&gt;   &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;int&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1   11286 12286   11227 12227      941</span>
<span class="co">#&gt; 2   chr1   11286 12286   11534 12534      752</span>
<span class="co">#&gt; 3   chr1   39049 40049   39329 40329      720</span>
<span class="co">#&gt; 4   chr1   39049 40049   39357 40357      692</span>
<span class="co">#&gt; 5   chr1   40058 41058   39329 40329      271</span>
<span class="co">#&gt; 6   chr1   40058 41058   39357 40357      299</span>
<span class="co">#&gt; 7   chr1   60180 61180   59205 60205       25</span>
<span class="co">#&gt; 8   chr1   60180 61180   59221 60221       41</span>
<span class="co">#&gt; 9   chr1   63631 64631   63110 64110      479</span>
<span class="co">#&gt; 10  chr1   97011 98011   96825 97825      814</span>
<span class="co">#&gt; # ... with 647,102 more rows</span>

<span class="co"># A records with no overlaps (i.e., `-v`)</span>
<span class="kw">bed_intersect</span>(x, y, <span class="dt">invert =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; Source: local data frame [523,587 x 3]</span>
<span class="co">#&gt; Groups: chrom [25]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;    chrom    start      end</span>
<span class="co">#&gt;    &lt;chr&gt;    &lt;int&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1   chrY 59366979 59367979</span>
<span class="co">#&gt; 2   chrY 59337389 59338389</span>
<span class="co">#&gt; 3   chrY 59333375 59334375</span>
<span class="co">#&gt; 4   chrY 59317052 59318052</span>
<span class="co">#&gt; 5   chrY 59305607 59306607</span>
<span class="co">#&gt; 6   chrY 59290521 59291521</span>
<span class="co">#&gt; 7   chrY 59277265 59278265</span>
<span class="co">#&gt; 8   chrY 59252221 59253221</span>
<span class="co">#&gt; 9   chrY 59247513 59248513</span>
<span class="co">#&gt; 10  chrY 59247031 59248031</span>
<span class="co">#&gt; # ... with 523,577 more rows</span></code></pre></div>
<p>One can achieve behaviour similar to BEDtools by combining <code>bed_intersect</code> with <code>dplyr</code> tools.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># `x` records with overlaps (i.e., `-wa`)</span>
<span class="kw">bed_intersect</span>(x, y) %&gt;%<span class="st"> </span><span class="kw">select</span>(chrom, <span class="dt">start =</span> start.x, <span class="dt">end =</span> end.x)
<span class="co">#&gt; # A tibble: 647,112 × 3</span>
<span class="co">#&gt;    chrom start   end</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1 11286 12286</span>
<span class="co">#&gt; 2   chr1 11286 12286</span>
<span class="co">#&gt; 3   chr1 39049 40049</span>
<span class="co">#&gt; 4   chr1 39049 40049</span>
<span class="co">#&gt; 5   chr1 40058 41058</span>
<span class="co">#&gt; 6   chr1 40058 41058</span>
<span class="co">#&gt; 7   chr1 60180 61180</span>
<span class="co">#&gt; 8   chr1 60180 61180</span>
<span class="co">#&gt; 9   chr1 63631 64631</span>
<span class="co">#&gt; 10  chr1 97011 98011</span>
<span class="co">#&gt; # ... with 647,102 more rows</span>

<span class="co"># `y` records with overlaps (i.e., `-wb`)</span>
<span class="kw">bed_intersect</span>(x, y) %&gt;%<span class="st"> </span><span class="kw">select</span>(chrom, <span class="dt">start =</span> start.y, <span class="dt">end =</span> end.y)
<span class="co">#&gt; # A tibble: 647,112 × 3</span>
<span class="co">#&gt;    chrom start   end</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1 11227 12227</span>
<span class="co">#&gt; 2   chr1 11534 12534</span>
<span class="co">#&gt; 3   chr1 39329 40329</span>
<span class="co">#&gt; 4   chr1 39357 40357</span>
<span class="co">#&gt; 5   chr1 39329 40329</span>
<span class="co">#&gt; 6   chr1 39357 40357</span>
<span class="co">#&gt; 7   chr1 59205 60205</span>
<span class="co">#&gt; 8   chr1 59221 60221</span>
<span class="co">#&gt; 9   chr1 63110 64110</span>
<span class="co">#&gt; 10  chr1 96825 97825</span>
<span class="co">#&gt; # ... with 647,102 more rows</span>

<span class="co"># Unique records in `x` (i.e., `-u`)</span>
<span class="kw">bed_intersect</span>(x, y) %&gt;%<span class="st"> </span><span class="kw">select</span>(chrom, <span class="dt">start =</span> start.x, <span class="dt">end =</span> end.x) %&gt;%<span class="st"> </span><span class="kw">unique</span>()
<span class="co">#&gt; # A tibble: 476,348 × 3</span>
<span class="co">#&gt;    chrom  start    end</span>
<span class="co">#&gt;    &lt;chr&gt;  &lt;int&gt;  &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1  11286  12286</span>
<span class="co">#&gt; 2   chr1  39049  40049</span>
<span class="co">#&gt; 3   chr1  40058  41058</span>
<span class="co">#&gt; 4   chr1  60180  61180</span>
<span class="co">#&gt; 5   chr1  63631  64631</span>
<span class="co">#&gt; 6   chr1  97011  98011</span>
<span class="co">#&gt; 7   chr1 102017 103017</span>
<span class="co">#&gt; 8   chr1 103140 104140</span>
<span class="co">#&gt; 9   chr1 107933 108933</span>
<span class="co">#&gt; 10  chr1 108645 109645</span>
<span class="co">#&gt; # ... with 476,338 more rows</span>

<span class="co"># Count `y` intervals that intersect each `x` interval</span>
<span class="kw">bed_intersect</span>(x, y) %&gt;%<span class="st"> </span><span class="kw">group_by</span>(chrom, start.x, end.x) %&gt;%<span class="st"> </span><span class="kw">summarize</span>(<span class="dt">count =</span> <span class="kw">n</span>())
<span class="co">#&gt; Source: local data frame [476,348 x 4]</span>
<span class="co">#&gt; Groups: chrom, start.x [?]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;    chrom start.x  end.x count</span>
<span class="co">#&gt;    &lt;chr&gt;   &lt;int&gt;  &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1   11286  12286     2</span>
<span class="co">#&gt; 2   chr1   39049  40049     2</span>
<span class="co">#&gt; 3   chr1   40058  41058     2</span>
<span class="co">#&gt; 4   chr1   60180  61180     2</span>
<span class="co">#&gt; 5   chr1   63631  64631     1</span>
<span class="co">#&gt; 6   chr1   97011  98011     2</span>
<span class="co">#&gt; 7   chr1  102017 103017     2</span>
<span class="co">#&gt; 8   chr1  103140 104140     1</span>
<span class="co">#&gt; 9   chr1  107933 108933     2</span>
<span class="co">#&gt; 10  chr1  108645 109645     1</span>
<span class="co">#&gt; # ... with 476,338 more rows</span></code></pre></div>
</div>
<div id="map" class="section level3">
<h3>Map</h3>
<p><code>bed_map</code> maps signals onto intervals. Summary statistics for mapped signals can be specific using NSE with name / value pairs.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bedfile &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">'extdata'</span>, <span class="st">'genes.hg19.chr22.bed.gz'</span>, <span class="dt">package =</span> <span class="st">'valr'</span>)
bgfile  &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">'extdata'</span>, <span class="st">'hela.h3k4.chip.bg.gz'</span>, <span class="dt">package =</span> <span class="st">'valr'</span>)

x &lt;-<span class="st"> </span><span class="kw">read_bed</span>(bedfile, <span class="dt">n_fields =</span> <span class="dv">6</span>)
y &lt;-<span class="st"> </span><span class="kw">read_bedgraph</span>(bgfile)

<span class="kw">bed_map</span>(x, y, <span class="dt">means =</span> <span class="kw">mean</span>(value.y), <span class="dt">sds =</span> <span class="kw">sd</span>(value.y))
<span class="co">#&gt; # A tibble: 591 × 5</span>
<span class="co">#&gt;    chrom  start.x    end.x    means       sds</span>
<span class="co">#&gt;    &lt;chr&gt;    &lt;int&gt;    &lt;int&gt;    &lt;dbl&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1  chr22 16150259 16193004 7.914286 7.5707309</span>
<span class="co">#&gt; 2  chr22 16162065 16172265 1.000000        NA</span>
<span class="co">#&gt; 3  chr22 16256331 16287937 1.000000 0.0000000</span>
<span class="co">#&gt; 4  chr22 17071647 17073700 1.000000 0.0000000</span>
<span class="co">#&gt; 5  chr22 17082800 17129720 1.117647 0.3270350</span>
<span class="co">#&gt; 6  chr22 17134598 17156430 1.294118 0.5878675</span>
<span class="co">#&gt; 7  chr22 17227758 17229328 1.000000        NA</span>
<span class="co">#&gt; 8  chr22 17264305 17302584 1.250000 0.5084039</span>
<span class="co">#&gt; 9  chr22 17308363 17310225 1.333333 0.5773503</span>
<span class="co">#&gt; 10 chr22 17385314 17385395 1.000000        NA</span>
<span class="co">#&gt; # ... with 581 more rows</span></code></pre></div>
</div>
<div id="subtract" class="section level3">
<h3>Subtract</h3>
<p><code>bed_substract()</code> removes <code>x</code> intervals that intersect with <code>y</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_subtract</span>(x, y)
<span class="co">#&gt; # A tibble: 722,786 × 3</span>
<span class="co">#&gt;     chrom start   end</span>
<span class="co">#&gt;    &lt;fctr&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1    chr1   214   649</span>
<span class="co">#&gt; 2    chr1  7150  7496</span>
<span class="co">#&gt; 3    chr1  8783 10135</span>
<span class="co">#&gt; 4    chr1 10714 11714</span>
<span class="co">#&gt; 5    chr1 17089 17319</span>
<span class="co">#&gt; 6    chr1 21953 22953</span>
<span class="co">#&gt; 7    chr1 25436 26436</span>
<span class="co">#&gt; 8    chr1 26818 27818</span>
<span class="co">#&gt; 9    chr1 28162 29162</span>
<span class="co">#&gt; 10   chr1 31952 32535</span>
<span class="co">#&gt; # ... with 722,776 more rows</span></code></pre></div>
</div>
<div id="window" class="section level3">
<h3>Window</h3>
<p><code>bed_window()</code> identifies <code>y</code> intervals that intersect an expanded window of <code>x</code> intervals.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> <span class="dv">100</span>)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> <span class="dv">100</span>)

<span class="co"># a few intersections</span>
<span class="kw">bed_intersect</span>(x, y)
<span class="co">#&gt; # A tibble: 0 × 6</span>
<span class="co">#&gt; # ... with 6 variables: chrom &lt;chr&gt;, start.x &lt;int&gt;, end.x &lt;int&gt;,</span>
<span class="co">#&gt; #   start.y &lt;int&gt;, end.y &lt;int&gt;, .overlap &lt;int&gt;</span>

<span class="co"># can be expanded by casting a wider net</span>
<span class="kw">bed_window</span>(x, y, genome, <span class="dt">both =</span> <span class="fl">1e6</span>)
<span class="co">#&gt; # A tibble: 7 × 6</span>
<span class="co">#&gt;   chrom   start.x     end.x   start.y     end.y .overlap</span>
<span class="co">#&gt;   &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;     &lt;int&gt;     &lt;int&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1 chr15  30136567  30137567  30974544  30975544     1000</span>
<span class="co">#&gt; 2 chr19  51076578  51077578  50325811  50326811     1000</span>
<span class="co">#&gt; 3  chr4  15320341  15321341  15739329  15740329     1000</span>
<span class="co">#&gt; 4  chr4  15768825  15769825  15739329  15740329     1000</span>
<span class="co">#&gt; 5  chr5 109132411 109133411 108388085 108389085     1000</span>
<span class="co">#&gt; 6  chr6  93589849  93590849  94561847  94562847     1000</span>
<span class="co">#&gt; 7  chrX   8921331   8922331   9237337   9238337     1000</span></code></pre></div>
</div>
<div id="closest" class="section level3">
<h3>Closest</h3>
<p><code>bed_closest()</code> identifies <code>y</code> intervals that are closest to <code>x</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> <span class="dv">100</span>)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> <span class="dv">100</span>)

<span class="kw">bed_closest</span>(x, y)
<span class="co">#&gt; # A tibble: 100 × 7</span>
<span class="co">#&gt;    chrom   start.x     end.x   start.y     end.y .overlap .distance</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;     &lt;int&gt;     &lt;int&gt;    &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1  69226270  69227270  84958397  84959397        0  15731127</span>
<span class="co">#&gt; 2   chr1 136064461 136065461 149230830 149231830        0  13165369</span>
<span class="co">#&gt; 3   chr1 137039233 137040233 149230830 149231830        0  12190597</span>
<span class="co">#&gt; 4   chr1 186407828 186408828 193230588 193231588        0   6821760</span>
<span class="co">#&gt; 5   chr1 205908686 205909686 208083506 208084506        0   2173820</span>
<span class="co">#&gt; 6   chr1 238184687 238185687 213265325 213266325        0 -24918362</span>
<span class="co">#&gt; 7  chr10    229041    230041   2424084   2425084        0   2194043</span>
<span class="co">#&gt; 8  chr10 126188779 126189779 123816371 123817371        0  -2371408</span>
<span class="co">#&gt; 9  chr10 128373549 128374549 123816371 123817371        0  -4556178</span>
<span class="co">#&gt; 10 chr11  28526613  28527613  34586206  34587206        0   6058593</span>
<span class="co">#&gt; # ... with 90 more rows</span></code></pre></div>
</div>
</div>
<div id="randomzing-intervals" class="section level2 tabset">
<h2>Randomzing intervals</h2>
<p><code>valr</code> provides methods for creating new random intervals or permutations of existing intervals:</p>
<ul>
<li><code>bed_random</code> generates random intervals from an input <code>genome</code>.</li>
<li><code>bed_shuffle</code> shuffles coordinates given a set of input intervals.</li>
<li>Random sampling of input intervals is done with <code>dplyr</code>.</li>
</ul>
<div id="random" class="section level3">
<h3>Random</h3>
<p><code>bed_random</code> generates random intervals from an input genome. The numbers of intervals from each <code>chrom</code> are proporitional to each chrom <code>size</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome, <span class="dt">n =</span> <span class="fl">1e6</span>, <span class="dt">length =</span> <span class="fl">1e3</span>)
x
<span class="co">#&gt; # A tibble: 1,000,000 × 3</span>
<span class="co">#&gt;    chrom     start       end</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1  chr13    133317    134317</span>
<span class="co">#&gt; 2   chr5 146742237 146743237</span>
<span class="co">#&gt; 3   chrY   2867981   2868981</span>
<span class="co">#&gt; 4  chr13   1948140   1949140</span>
<span class="co">#&gt; 5   chr1 140176126 140177126</span>
<span class="co">#&gt; 6  chr10  83069014  83070014</span>
<span class="co">#&gt; 7   chr3 191524299 191525299</span>
<span class="co">#&gt; 8  chr17  67751740  67752740</span>
<span class="co">#&gt; 9   chr1  52963225  52964225</span>
<span class="co">#&gt; 10  chr2 189475195 189476195</span>
<span class="co">#&gt; # ... with 999,990 more rows</span>

<span class="co"># numbers of sampled intervals are proportional to chrom size</span>
<span class="kw">group_by</span>(x, chrom) %&gt;%<span class="st"> </span><span class="kw">summarize</span>(<span class="dt">n =</span> <span class="kw">n</span>()) %&gt;%<span class="st"> </span><span class="kw">arrange</span>(<span class="kw">desc</span>(n))
<span class="co">#&gt; # A tibble: 25 × 2</span>
<span class="co">#&gt;    chrom     n</span>
<span class="co">#&gt;    &lt;chr&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1 80173</span>
<span class="co">#&gt; 2   chr2 78649</span>
<span class="co">#&gt; 3   chr3 64310</span>
<span class="co">#&gt; 4   chr4 61647</span>
<span class="co">#&gt; 5   chr5 58144</span>
<span class="co">#&gt; 6   chr6 55427</span>
<span class="co">#&gt; 7   chr7 51551</span>
<span class="co">#&gt; 8   chrX 49973</span>
<span class="co">#&gt; 9   chr8 47014</span>
<span class="co">#&gt; 10  chr9 45482</span>
<span class="co">#&gt; # ... with 15 more rows</span></code></pre></div>
</div>
<div id="sample" class="section level3">
<h3>Sample</h3>
<p>Sampling can be done using <code>dplyr</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="co"># sample by number</span>
<span class="kw">sample_n</span>(x, <span class="fl">1e3</span>, <span class="dt">replace =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; # A tibble: 1,000 × 3</span>
<span class="co">#&gt;    chrom     start       end</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1  55148012  55149012</span>
<span class="co">#&gt; 2  chr17   3893838   3894838</span>
<span class="co">#&gt; 3  chr17  65875979  65876979</span>
<span class="co">#&gt; 4   chr5  46816851  46817851</span>
<span class="co">#&gt; 5   chr9  93694268  93695268</span>
<span class="co">#&gt; 6   chr8 129140992 129141992</span>
<span class="co">#&gt; 7   chr2 135287753 135288753</span>
<span class="co">#&gt; 8   chr4 155382633 155383633</span>
<span class="co">#&gt; 9   chr6  81758356  81759356</span>
<span class="co">#&gt; 10  chr9  86842771  86843771</span>
<span class="co">#&gt; # ... with 990 more rows</span>

<span class="co"># or fraction</span>
<span class="kw">sample_frac</span>(x, <span class="fl">0.1</span>, <span class="dt">replace =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; # A tibble: 100,000 × 3</span>
<span class="co">#&gt;    chrom     start       end</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1  chr15  36017878  36018878</span>
<span class="co">#&gt; 2  chr16  37901199  37902199</span>
<span class="co">#&gt; 3   chr6 167454704 167455704</span>
<span class="co">#&gt; 4  chr21  17973802  17974802</span>
<span class="co">#&gt; 5  chr18  23277813  23278813</span>
<span class="co">#&gt; 6  chr17  23001295  23002295</span>
<span class="co">#&gt; 7   chr6  87550464  87551464</span>
<span class="co">#&gt; 8   chr3 111463738 111464738</span>
<span class="co">#&gt; 9   chr4  84282050  84283050</span>
<span class="co">#&gt; 10  chr6 155827052 155828052</span>
<span class="co">#&gt; # ... with 99,990 more rows</span>

<span class="co"># or sample intervals within groups</span>
<span class="kw">group_by</span>(x, chrom) %&gt;%<span class="st"> </span><span class="kw">sample_n</span>(<span class="dv">1</span>)
<span class="co">#&gt; Source: local data frame [25 x 3]</span>
<span class="co">#&gt; Groups: chrom [25]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;    chrom     start       end</span>
<span class="co">#&gt;    &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1 206265345 206266345</span>
<span class="co">#&gt; 2  chr10 131836587 131837587</span>
<span class="co">#&gt; 3  chr11  41509023  41510023</span>
<span class="co">#&gt; 4  chr12  34377704  34378704</span>
<span class="co">#&gt; 5  chr13  22974007  22975007</span>
<span class="co">#&gt; 6  chr14  55362125  55363125</span>
<span class="co">#&gt; 7  chr15  99403504  99404504</span>
<span class="co">#&gt; 8  chr16  57827073  57828073</span>
<span class="co">#&gt; 9  chr17  37833267  37834267</span>
<span class="co">#&gt; 10 chr18  19672782  19673782</span>
<span class="co">#&gt; # ... with 15 more rows</span></code></pre></div>
</div>
<div id="shuffle" class="section level3">
<h3>Shuffle</h3>
<p><code>bed_shuffle</code> shuffles input intervals. Interval sizes are equal in the input and output.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">bed_shuffle</span>(x)

<span class="kw">any</span>(x$start ==<span class="st"> </span>y$start)

<span class="kw">all</span>(x$end -<span class="st"> </span>x$start ==<span class="st"> </span>y$end -<span class="st"> </span>y$start)</code></pre></div>
</div>
</div>
<div id="other-topics" class="section level2">
<h2>Other topics</h2>
<div id="grouping-related-intervals" class="section level3">
<h3>Grouping related intervals</h3>
<p>The <code>group_by</code> operation from <code>dplyr</code> serves a similar purpose to BEDtools <code>groupby</code>, and can be combined with <code>dplyr::summarize</code> to calculate summary statistics from groups.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_intersect</span>(x, y) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(chrom) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="dt">overlap.total =</span> <span class="kw">sum</span>(.overlap))
<span class="co">#&gt; # A tibble: 25 × 2</span>
<span class="co">#&gt;    chrom overlap.total</span>
<span class="co">#&gt;    &lt;chr&gt;         &lt;int&gt;</span>
<span class="co">#&gt; 1   chr1      26101908</span>
<span class="co">#&gt; 2  chr10      13962398</span>
<span class="co">#&gt; 3  chr11      14089075</span>
<span class="co">#&gt; 4  chr12      14042289</span>
<span class="co">#&gt; 5  chr13      11941402</span>
<span class="co">#&gt; 6  chr14      11128674</span>
<span class="co">#&gt; 7  chr15      10796956</span>
<span class="co">#&gt; 8  chr16       9569943</span>
<span class="co">#&gt; 9  chr17       8261750</span>
<span class="co">#&gt; 10 chr18       8041223</span>
<span class="co">#&gt; # ... with 15 more rows</span></code></pre></div>
</div>
</div>
</div>
<div id="interval-statistics" class="section level1 tabset">
<h1>Interval Statistics</h1>
<p><code>valr</code> provides several methods to assess statistical properties of interval sets including:</p>
<ul>
<li><code>bed_fisher()</code>: measure overlap significance of two sets of intervals.</li>
<li><code>bed_absdist()</code>: XXX</li>
<li><code>bed_reldist()</code>: quantify relative distances between query intervals and closest reference intervals</li>
<li><code>bed_jaccard()</code>: quantify extent of overlap between two sets of intervals</li>
<li><code>bed_projection()</code>: XXX</li>
</ul>
<p>Several of these methods were described in the <a href="http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002529">Genometricorr</a> software package.</p>
<div id="fishers-test" class="section level2">
<h2>Fisher’s test</h2>
<p>The Fisher’s test assesses whether two sets of intervals are drawn from the same background genome.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_fisher</span>(x, y, genome)
<span class="co">#&gt;   estimate p.value conf.low conf.high                             method</span>
<span class="co">#&gt; 1 2.340094       0 2.326192  2.354199 Fisher's Exact Test for Count Data</span>
<span class="co">#&gt;   alternative</span>
<span class="co">#&gt; 1   two.sided</span></code></pre></div>
</div>
<div id="absolute-distance" class="section level2">
<h2>Absolute distance</h2>
<p><code>bed_absdist()</code> - XXX</p>
</div>
<div id="relative-distance" class="section level2">
<h2>Relative distance</h2>
<p><code>bed_reldist()</code> computes the relative distance between a query interval and the two closest reference intervals. The relative distance can range between <code>[0,0.5]</code>. If the overall distribution of distances is biased toward zero, then the query and reference intervals tend to be closer in space (<a href="http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002529">17</a>). By default a summary with the frequency of each relative distance is reported.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_reldist</span>(x, y)
<span class="co">#&gt; # A tibble: 51 × 4</span>
<span class="co">#&gt;    reldist counts  total       freq</span>
<span class="co">#&gt;      &lt;dbl&gt;  &lt;int&gt;  &lt;int&gt;      &lt;dbl&gt;</span>
<span class="co">#&gt; 1     0.00  20049 999948 0.02005004</span>
<span class="co">#&gt; 2     0.01  20212 999948 0.02021305</span>
<span class="co">#&gt; 3     0.02  20127 999948 0.02012805</span>
<span class="co">#&gt; 4     0.03  20250 999948 0.02025105</span>
<span class="co">#&gt; 5     0.04  19919 999948 0.01992004</span>
<span class="co">#&gt; 6     0.05  19838 999948 0.01983903</span>
<span class="co">#&gt; 7     0.06  19793 999948 0.01979403</span>
<span class="co">#&gt; 8     0.07  20060 999948 0.02006104</span>
<span class="co">#&gt; 9     0.08  20043 999948 0.02004404</span>
<span class="co">#&gt; 10    0.09  20010 999948 0.02001104</span>
<span class="co">#&gt; # ... with 41 more rows</span></code></pre></div>
</div>
<div id="jaccard-similarity" class="section level2">
<h2>Jaccard similarity</h2>
<p><code>bed_jaccard()</code> quantifies the extent of overlap between to sets of intervals. The Jaccard statistic takes values of <code>[0,1]</code> and is measured as:</p>
<p><span class="math display">\[
J(x,y) = \frac{\mid x \bigcap y \mid}
              {\mid x \bigcup y \mid} 
       = 
         \frac{\mid x \bigcap y \mid}
              {\mid x \mid + \mid y \mid - \mid x \bigcap y \mid}
\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">bed_jaccard</span>(x, y)
<span class="co">#&gt; # A tibble: 1 × 4</span>
<span class="co">#&gt;       len_i      len_u  jaccard      n</span>
<span class="co">#&gt;       &lt;int&gt;      &lt;int&gt;    &lt;dbl&gt;  &lt;int&gt;</span>
<span class="co">#&gt; 1 323364276 2000000000 0.192865 646278</span></code></pre></div>
</div>
<div id="projection" class="section level2">
<h2>Projection</h2>
<p><code>bed_projection()</code> TBD</p>
</div>
</div>
<div id="benchmarks" class="section level1">
<h1>Benchmarks</h1>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># two sets of 1e6 random 1 kb intervals from hg19</span>
x &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)
y &lt;-<span class="st"> </span><span class="kw">bed_random</span>(genome)

<span class="kw">library</span>(microbenchmark)
<span class="kw">microbenchmark</span>(
  <span class="kw">bed_random</span>(genome),
  <span class="kw">bed_closest</span>(x, y),
  <span class="kw">bed_intersect</span>(x, y),
  <span class="kw">bed_merge</span>(x),
  <span class="kw">bed_subtract</span>(x, y),
  <span class="kw">bed_complement</span>(x, genome),
  <span class="dt">times =</span> <span class="dv">1</span>,
  <span class="dt">unit =</span> <span class="st">'s'</span>
)
<span class="co">#&gt; Unit: seconds</span>
<span class="co">#&gt;                       expr       min        lq      mean    median</span>
<span class="co">#&gt;         bed_random(genome) 0.1156026 0.1156026 0.1156026 0.1156026</span>
<span class="co">#&gt;          bed_closest(x, y) 4.6729700 4.6729700 4.6729700 4.6729700</span>
<span class="co">#&gt;        bed_intersect(x, y) 1.7085081 1.7085081 1.7085081 1.7085081</span>
<span class="co">#&gt;               bed_merge(x) 2.2527479 2.2527479 2.2527479 2.2527479</span>
<span class="co">#&gt;         bed_subtract(x, y) 1.8617186 1.8617186 1.8617186 1.8617186</span>
<span class="co">#&gt;  bed_complement(x, genome) 2.6811655 2.6811655 2.6811655 2.6811655</span>
<span class="co">#&gt;         uq       max neval</span>
<span class="co">#&gt;  0.1156026 0.1156026     1</span>
<span class="co">#&gt;  4.6729700 4.6729700     1</span>
<span class="co">#&gt;  1.7085081 1.7085081     1</span>
<span class="co">#&gt;  2.2527479 2.2527479     1</span>
<span class="co">#&gt;  1.8617186 1.8617186     1</span>
<span class="co">#&gt;  2.6811655 2.6811655     1</span></code></pre></div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
